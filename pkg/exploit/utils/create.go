package utils

import (
	"context"
	"fmt"
	"k8sRBACdetect/pkg/request"

	admissionv1 "k8s.io/api/admissionregistration/v1"
	appsV1 "k8s.io/api/apps/v1"
	authenticationv1 "k8s.io/api/authentication/v1"
	batchv1 "k8s.io/api/batch/v1"
	coreV1 "k8s.io/api/core/v1"
	policyv1beta1 "k8s.io/api/policy/v1beta1"
	rbacV1 "k8s.io/api/rbac/v1"
	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateToken(token string, namespace string, sa string) (string, error) {
	clientset := request.GetClientSet(token)
	tokenRequest := &authenticationv1.TokenRequest{
		Spec: authenticationv1.TokenRequestSpec{
			//Audiences: []string{"travor"},
			ExpirationSeconds: func() *int64 {
				expirationSeconds := int64(999999)
				return &expirationSeconds
			}(),
		},
	}
	tokenResponse, err := clientset.CoreV1().ServiceAccounts(namespace).CreateToken(context.TODO(), sa, tokenRequest, metaV1.CreateOptions{})
	if err != nil {
		return "", err
	}
	return tokenResponse.Status.Token, nil

}
func CreateSecret(token string, saName string, saNamespace string) error {
	fmt.Println("[!] Note that after CreateSecret, you need the getSecret permission to obtain the token content.")
	clientset := request.GetClientSet(token)
	secret := &coreV1.Secret{
		ObjectMeta: metaV1.ObjectMeta{
			Name:      saName,
			Namespace: saNamespace, //secrets can only be created in the ns where sa is located
			Annotations: map[string]string{
				"kubernetes.io/service-account.name": saName,
			},
		},
		Type: coreV1.SecretTypeServiceAccountToken,
	}
	_, err := clientset.CoreV1().Secrets(saNamespace).Create(context.TODO(), secret, metaV1.CreateOptions{})
	if err != nil {
		return err
	}
	fmt.Println("[√] secret created successfully")

	return nil
}

func CreateClusterRoleBinding(token string, saName string, saNS string, bindName string) error {
	clientset := request.GetClientSet(token)
	clusterRoleBinding := &rbacV1.ClusterRoleBinding{
		ObjectMeta: metaV1.ObjectMeta{
			Name: bindName,
		},
		Subjects: []rbacV1.Subject{
			{
				Kind:      "ServiceAccount",
				Name:      saName,
				Namespace: saNS,
			},
		},
		RoleRef: rbacV1.RoleRef{
			Kind: "ClusterRole",
			Name: "cluster-admin",
		},
	}

	// Create the ClusterRoleBinding in the cluster
	_, err := clientset.RbacV1().ClusterRoleBindings().Create(context.Background(), clusterRoleBinding, metaV1.CreateOptions{})
	if err != nil {
		return nil
	} else {
		fmt.Printf("[√] ClusterRoleBinding created successfully\n")
	}
	return nil

}
func CreateRoleBinding(token string, saName string, saNS string, bindName string, roleName string) error {
	clientset := request.GetClientSet(token)
	RoleBinding := &rbacV1.RoleBinding{
		ObjectMeta: metaV1.ObjectMeta{
			Name: bindName,
		},
		Subjects: []rbacV1.Subject{
			{
				Kind:      "ServiceAccount",
				Name:      saName,
				Namespace: saNS,
			},
		},
		RoleRef: rbacV1.RoleRef{
			Kind: "Role",
			Name: roleName,
		},
	}

	// Create the ClusterRoleBinding in the cluster
	_, err := clientset.RbacV1().RoleBindings(saNS).Create(context.Background(), RoleBinding, metaV1.CreateOptions{})
	if err != nil {
		return err
	}

	fmt.Println("[√] 成功CreateRoleBinding", bindName)
	return nil
}

/*
* roles(create) + rolebindings(create)
* When there is no bind permission of the high-privilege SA, you can use the create permission of the Role to create and bind the SA with high permissions.
 */
// func CreateClusterRole(token string, clusterRolename string) {
// 	clientset := request.GetClientSet(token)
// 	clusterRole := &rbacV1.ClusterRole{
// 		ObjectMeta: metaV1.ObjectMeta{
// 			Name: clusterRolename,
// 		},
// 		Rules: []rbacV1.PolicyRule{
// 			{
// 				Verbs:     []string{"*"},
// 				APIGroups: []string{""},
// 				Resources: []string{"*"},
// 			},
// 		},
// 	}

// 	// Create the ClusterRole
// 	_, err := clientset.RbacV1().ClusterRoles().Create(context.Background(), clusterRole, metaV1.CreateOptions{})
// 	if err != nil {
// 		fmt.Printf("Error creating ClusterRole: %v\n", err)
// 	} else {
// 		fmt.Println("ClusterRole created successfully.")
// 	}
// }

// func CreateRole(token string, roleName string, roleNamespace string) {
// 	clientset := request.GetClientSet(token)
// 	role := &v1.Role{
// 		ObjectMeta: metaV1.ObjectMeta{
// 			Name: roleName,
// 		},
// 		Rules: []v1.PolicyRule{
// 			{
// 				Verbs:     []string{"*"},
// 				APIGroups: []string{""},
// 				Resources: []string{"*"},
// 			},
// 		},
// 	}

// 	namespace := roleNamespace // Replace with your desired namespace

// 	// Create the Role
// 	_, err := clientset.RbacV1().Roles(namespace).Create(context.Background(), role, metaV1.CreateOptions{})
// 	if err != nil {
// 		fmt.Printf("Error creating Role: %v\n", err)
// 	} else {
// 		fmt.Println("Role created successfully.")
// 	}
// }

func CreatePod(token string, podNamespace string, podName string, targetSaName string, nodeName string) error {
	clientset := request.GetClientSet(token)
	newPod := &coreV1.Pod{
		ObjectMeta: metaV1.ObjectMeta{
			Name: podName, // Replaced with the name of the Pod
		},
		Spec: coreV1.PodSpec{
			Containers: []coreV1.Container{
				{
					Name:  "my-container",
					Image: "nginx",
				},
			},
			NodeName:           nodeName,
			ServiceAccountName: targetSaName, // Replace with the name of the ServiceAccount to use
		},
	}

	createdPod, err := clientset.CoreV1().Pods(podNamespace).Create(context.TODO(), newPod, metaV1.CreateOptions{})
	if err != nil {
		return err
	}
	fmt.Printf("[√] Pod %s in namespace %s created with ServiceAccount: %s\n", createdPod.Name, createdPod.Namespace, createdPod.Spec.ServiceAccountName)

	return nil
	//After creating the pod, obtain the sa mounted by the pod.

}

func CreatePodEviction(token string, namespace string, podName string) error {
	clientset := request.GetClientSet(token)
	eviction := &policyv1beta1.Eviction{
		ObjectMeta: metaV1.ObjectMeta{
			Name:      podName,
			Namespace: namespace,
		},
		DeleteOptions: &metaV1.DeleteOptions{
			GracePeriodSeconds: new(int64), // Use pointer to set it to 0 (immediate deletion).
		},
	}

	// eviction.OwnerReferences = []metaV1.OwnerReference{
	// 	{
	// 		APIVersion: "v1",
	// 		Kind:       "Pod",
	// 		Name:       podName,
	// 		UID:        podUid,
	// 	},
	// }
	err := clientset.CoreV1().Pods(namespace).Evict(context.TODO(), eviction)
	if err != nil {
		return err
	}
	fmt.Println("[√] Expelled the", namespace+"/"+podName)
	return nil
}
func CreatePodController(token string, controllerType string, podControllerNamespace string, targetSaName string, podControllerName string, nodeName string) error {
	clientset := request.GetClientSet(token)
	if controllerType == "deployments" {
		deployment := &appsV1.Deployment{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: appsV1.DeploymentSpec{
				Replicas: int32Ptr(1),
				Selector: &metaV1.LabelSelector{
					MatchLabels: map[string]string{
						podControllerName: podControllerName,
					},
				},
				Template: coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						NodeName:           nodeName,
						ServiceAccountName: targetSaName,
						Containers: []coreV1.Container{
							{
								Name:  "test-container",
								Image: "nginx",
							},
						},
					},
				},
			},
		}
		_, err := clientset.AppsV1().Deployments(podControllerNamespace).Create(context.TODO(), deployment, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("Deployment %s created successfully.\n", podControllerName)

	} else if controllerType == "statefulsets" {
		statefulSet := &appsV1.StatefulSet{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: appsV1.StatefulSetSpec{
				Replicas: int32Ptr(1),
				Selector: &metaV1.LabelSelector{
					MatchLabels: map[string]string{
						podControllerName: podControllerName,
					},
				},
				Template: coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						NodeName:           nodeName,
						ServiceAccountName: targetSaName,
						Containers: []coreV1.Container{
							{
								Name:  "test-container",
								Image: "nginx",
							},
						},
					},
				},
				ServiceName: "example-service",
			},
		}

		_, err := clientset.AppsV1().StatefulSets(podControllerNamespace).Create(context.TODO(), statefulSet, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("StatefulSet %s created successfully.\n", podControllerName)

	} else if controllerType == "replicasets" {
		replicaSet := &appsV1.ReplicaSet{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: appsV1.ReplicaSetSpec{
				Replicas: int32Ptr(1),
				Selector: &metaV1.LabelSelector{
					MatchLabels: map[string]string{
						podControllerName: podControllerName,
					},
				},
				Template: coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						NodeName:           nodeName,
						ServiceAccountName: targetSaName,
						Containers: []coreV1.Container{
							{
								Name:  "test-container",
								Image: "nginx",
							},
						},
					},
				},
			},
		}
		_, err := clientset.AppsV1().ReplicaSets(podControllerNamespace).Create(context.TODO(), replicaSet, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("ReplicaSet %s created successfully.\n", podControllerName)

	} else if controllerType == "daemonsets" {
		daemonSet := &appsV1.DaemonSet{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: appsV1.DaemonSetSpec{
				Selector: &metaV1.LabelSelector{
					MatchLabels: map[string]string{
						podControllerName: podControllerName,
					},
				},
				Template: coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						ServiceAccountName: targetSaName,
						Containers: []coreV1.Container{
							{
								Name:  "test-container",
								Image: "nginx",
							},
						},
					},
				},
			},
		}
		_, err := clientset.AppsV1().DaemonSets(podControllerNamespace).Create(context.TODO(), daemonSet, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("ReplicaSet %s created successfully.\n", podControllerName)

	} else if controllerType == "jobs" {
		job := &batchv1.Job{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: batchv1.JobSpec{
				Template: coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						NodeName:           nodeName,
						ServiceAccountName: targetSaName, // Specify the ServiceAccount to use
						Containers: []coreV1.Container{
							{
								Name:  "container",
								Image: "nginx",
								// Command: []string{
								// 	"/your/command",
								// },
							},
						},
						RestartPolicy: coreV1.RestartPolicyOnFailure,
					},
				},
				BackoffLimit: new(int32), // Set the number of retries for the Job
			},
		}
		*job.Spec.BackoffLimit = 1
		result, err := clientset.BatchV1().Jobs(podControllerNamespace).Create(context.TODO(), job, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("Job %q created\n", result.GetObjectMeta().GetName())

	} else if controllerType == "cronjobs" {
		cronJob := &batchv1.CronJob{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: batchv1.CronJobSpec{
				Schedule:          "*/1 * * * *",
				ConcurrencyPolicy: batchv1.ForbidConcurrent,
				JobTemplate: batchv1.JobTemplateSpec{
					Spec: batchv1.JobSpec{
						Template: coreV1.PodTemplateSpec{
							ObjectMeta: metaV1.ObjectMeta{
								Labels: map[string]string{
									podControllerName: podControllerName,
								},
							},
							Spec: coreV1.PodSpec{
								NodeName:           nodeName,
								ServiceAccountName: targetSaName,
								Containers: []coreV1.Container{
									{
										Name:  "container",
										Image: "nginx",
									},
								},
								RestartPolicy: coreV1.RestartPolicyOnFailure,
							},
						},
					},
				},
			},
		}
		result, err := clientset.BatchV1().CronJobs(podControllerNamespace).Create(context.Background(), cronJob, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("CronJob %q created\n", result.GetObjectMeta().GetName())

	} else if controllerType == "replicationcontrollers" {
		replicationcontroller := &coreV1.ReplicationController{
			ObjectMeta: metaV1.ObjectMeta{
				Name: podControllerName,
			},
			Spec: coreV1.ReplicationControllerSpec{
				Replicas: int32Ptr(1),
				Selector: map[string]string{podControllerName: podControllerName},
				Template: &coreV1.PodTemplateSpec{
					ObjectMeta: metaV1.ObjectMeta{
						Labels: map[string]string{
							podControllerName: podControllerName,
						},
					},
					Spec: coreV1.PodSpec{
						NodeName:           nodeName,
						ServiceAccountName: targetSaName,
						Containers: []coreV1.Container{
							{
								Name:  "test-container",
								Image: "nginx",
							},
						},
					},
				},
			},
		}
		result, err := clientset.CoreV1().ReplicationControllers(podControllerNamespace).Create(context.Background(), replicationcontroller, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Printf("CronJob %q created\n", result.GetObjectMeta().GetName())

	}
	return nil
}

func CreateWebhookConfig(token string, webhookconfigType string, webhookURL string, ca string) error {
	clientset := request.GetClientSet(token)
	var sideEffects admissionv1.SideEffectClass
	sideEffects = "None"
	if webhookconfigType == "mutatingwebhookconfigurations" {
		mutatingWebhookConfig := &admissionv1.MutatingWebhookConfiguration{
			ObjectMeta: metaV1.ObjectMeta{
				Name: "example-mutating-webhook-config",
			},
			Webhooks: []admissionv1.MutatingWebhook{
				{
					SideEffects:             &sideEffects,
					AdmissionReviewVersions: []string{"v1", "v1beta1"},
					Name:                    "a.b.c",
					ClientConfig: admissionv1.WebhookClientConfig{
						URL:      &webhookURL, // Set up your webhook URL
						CABundle: []byte(ca),  // Set up your CA Bundle
					},
					Rules: []admissionv1.RuleWithOperations{
						{
							Operations: []admissionv1.OperationType{
								admissionv1.Create, admissionv1.Update,
							},
							Rule: admissionv1.Rule{
								APIGroups:   []string{"*"},
								APIVersions: []string{"*"},
								Resources:   []string{"*"},
							},
						},
					},
				},
			},
		}

		result, err := clientset.AdmissionregistrationV1().MutatingWebhookConfigurations().Create(context.TODO(), mutatingWebhookConfig, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Println("[√] Created successfully", result.GetObjectMeta().GetName())
	} else if webhookconfigType == "validatingwebhookconfigurations" {
		validatingWebhookConfig := &admissionv1.ValidatingWebhookConfiguration{
			ObjectMeta: metaV1.ObjectMeta{
				Name: "example-validating-webhook-config",
			},
			Webhooks: []admissionv1.ValidatingWebhook{
				{
					Name: "example-validating-webhook",
					ClientConfig: admissionv1.WebhookClientConfig{
						URL:      &webhookURL, // Set up your Webhook URL
						CABundle: []byte(ca),  // Set up your CA Bundle
					},
					Rules: []admissionv1.RuleWithOperations{
						{
							Operations: []admissionv1.OperationType{
								admissionv1.Create, admissionv1.Update,
							},
							Rule: admissionv1.Rule{
								APIGroups:   []string{"*"},
								APIVersions: []string{"*"},
								Resources:   []string{"*"},
							},
						},
					},
				},
			},
		}

		result, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().Create(context.TODO(), validatingWebhookConfig, metaV1.CreateOptions{})
		if err != nil {
			return err
		}
		fmt.Println("[√] Created successfully", result.GetObjectMeta().GetName())
	}

	return nil
}

func int32Ptr(i int32) *int32 {
	return &i
}
